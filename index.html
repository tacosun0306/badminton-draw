<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¾½çƒé…å°ç³»çµ±</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 15px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: 14px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }

        .card h3 {
            color: #667eea;
            margin-bottom: 12px;
            font-size: 18px;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 16px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #764ba2;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .players-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .player-badge {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #667eea;
            text-align: center;
            font-size: 14px;
        }

        .status-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #ddd;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .courts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .court {
            background: #f8f9fa;
            border: 3px solid #667eea;
            border-radius: 12px;
            padding: 20px;
        }

        .court.finished {
            border-color: #28a745;
            background: #d4edda;
        }

        .court-title {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        .court-players {
            margin-bottom: 15px;
        }

        .player-item {
            background: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .waiting-player {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 4px 6px;
            border-radius: 4px;
            text-align: center;
            color: #856404;
            font-weight: 500;
            font-size: 12px;
        }
        
        .waiting-player small {
            display: block;
            margin-top: 1px;
            font-size: 10px;
            color: #856404;
        }

        .next-round-box {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        }

        .empty-state {
            text-align: center;
            color: #999;
            padding: 20px;
        }

        .hint {
            background: #e7f3ff;
            padding: 10px 15px;
            border-radius: 8px;
            color: #004085;
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¸ ç¾½çƒé…å°ç³»çµ±</h1>
            <p>ä¾åˆ°å ´é †åºç™»è¨˜ï¼Œè‡ªå‹•åˆ†é…å ´æ¬¡</p>
        </div>

        <!-- çƒå“¡ç™»è¨˜è¼¸å…¥æ¬„ -->
        <div class="card" style="position: sticky; top: 10px; z-index: 100; background: white; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
            <div class="input-group" style="margin-bottom: 0;">
                <input 
                    type="text" 
                    id="playerNameInput" 
                    placeholder="è¼¸å…¥ä½ çš„å§“å" 
                    onkeypress="if(event.key === 'Enter') addPlayer()">
                <button class="btn btn-primary" onclick="addPlayer()">ç™»è¨˜å…¥å ´</button>
                <button class="btn btn-danger" onclick="resetGame()">é‡ç½®</button>
            </div>
        </div>

        <!-- ç•¶å‰æ¯”è³½å’Œç­‰å€™å€ -->
        <div id="currentMatch" style="display: none;">
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
                <!-- ç•¶å‰æ¯”è³½ -->
                <div class="card">
                    <h3>ğŸ¯ ç•¶å‰æ¯”è³½</h3>
                    <div class="courts-container" id="courtsContainer"></div>
                </div>
                
                <!-- ç­‰å€™å€ -->
                <div class="card" id="waitingBoxCard" style="display: none;">
                    <h3>â³ ç­‰å€™å€</h3>
                    <div id="waitingPlayers" style="display: grid; gap: 10px;"></div>
                </div>
            </div>
        </div>

        <!-- ç‹€æ…‹é¡¯ç¤ºå’Œçƒå“¡åˆ—è¡¨ -->
        <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 20px;">
            <!-- ç‹€æ…‹é¡¯ç¤º -->
            <div class="card">
                <h3>ğŸ“Š ç‹€æ…‹</h3>
                <div class="status-box">
                    <div class="status-item">
                        <span>å·²ç™»è¨˜ï¼š</span>
                        <strong id="totalPlayers">0</strong>
                    </div>
                    <div class="status-item">
                        <span>å·²å®Œæˆï¼š</span>
                        <strong id="finishedMatches">0</strong>
                    </div>
                    <div class="status-item">
                        <span>å ´ä¸Šï¼š</span>
                        <strong id="onCourtCount">0</strong>
                    </div>
                </div>
                <div class="hint" style="margin-top: 10px; font-size: 12px;">
                    ğŸ’¡ æ»¿4äººè‡ªå‹•é–‹Aå ´<br>æ»¿8äººåŒæ™‚é–‹Bå ´
                </div>
            </div>

            <!-- çƒå“¡åˆ—è¡¨ -->
            <div class="card">
                <h3>ğŸ‘¥ å·²ç™»è¨˜çƒå“¡</h3>
                <div id="playersList"></div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <script>
        // Firebase é…ç½®
        const firebaseConfig = {
            apiKey: "AIzaSyC5dyhG0SZHqN1_TOyO8OWVSCbSltnEK1I",
            authDomain: "badminton-draw.firebaseapp.com",
            projectId: "badminton-draw",
            storageBucket: "badminton-draw.firebasestorage.app",
            messagingSenderId: "32998421872",
            appId: "1:32998421872:web:3d399ed7fd9eaf9ab24bb5",
            measurementId: "G-GY8824QHW4"
        };

        // åˆå§‹åŒ– Firebase
        let db = null;
        let isFirebaseEnabled = false;
        let unsubscribe = null;
        
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            isFirebaseEnabled = true;
            console.log('âœ… Firebase å·²é€£ç·š');
            startRealtimeSync();
        } catch (error) {
            console.error('âŒ Firebase åˆå§‹åŒ–å¤±æ•—:', error);
            isFirebaseEnabled = false;
        }

        let players = []; // æ‰€æœ‰çƒå“¡
        let playerMatchCount = {}; // è¨˜éŒ„æ¯å€‹çƒå“¡å·²æ‰“çš„å ´æ¬¡
        let nextPlayerIndex = 0; // ä¸‹ä¸€å€‹æŒ‰é †åºä¸Šå ´çš„çƒå“¡ç´¢å¼•
        let currentCourtA = []; // ç•¶å‰çƒå ´Açš„çƒå“¡
        let currentCourtB = []; // ç•¶å‰çƒå ´Bçš„çƒå“¡
        let courtAFinished = false;
        let courtBFinished = false;
        let finishedMatches = 0;

        // æ–°å¢çƒå“¡
        function addPlayer() {
            const input = document.getElementById('playerNameInput');
            const name = input.value.trim();
            
            if (!name) {
                alert('è«‹è¼¸å…¥å§“åï¼');
                return;
            }
            
            if (players.includes(name)) {
                alert('æ­¤å§“åå·²ç™»è¨˜ï¼');
                input.value = '';
                input.focus();
                return;
            }
            
            if (players.length >= 16) {
                alert('å·²é”æœ€å¤š16äººï¼Œç„¡æ³•å†ç™»è¨˜ï¼');
                return;
            }
            
            players.push(name);
            playerMatchCount[name] = 0;
            input.value = '';
            input.focus();
            updateDisplay();
            saveToFirebase();
            
            // æª¢æŸ¥æ˜¯å¦éœ€è¦è‡ªå‹•é–‹å§‹æ¯”è³½
            autoStartIfReady();
        }

        // è‡ªå‹•é–‹å§‹æ¯”è³½ï¼ˆæ»¿4äººæˆ–8äººï¼‰
        function autoStartIfReady() {
            const waitingCount = players.length - nextPlayerIndex;
            
            // å„ªå…ˆæª¢æŸ¥æ˜¯å¦æœ‰å·²çµæŸçš„çƒå ´å¯ä»¥é‡æ–°é–‹å§‹
            if (courtAFinished) {
                autoReplaceCourtA();
                return;
            }
            if (courtBFinished) {
                autoReplaceCourtB();
                return;
            }
            
            // å¦‚æœç•¶å‰æ²’æœ‰æ¯”è³½é€²è¡Œä¸­
            if (currentCourtA.length === 0 && currentCourtB.length === 0) {
                if (waitingCount >= 4) {
                    nextMatch();
                }
            }
            // å¦‚æœAå ´æœ‰æ¯”è³½ä½†Bå ´ç©ºè‘—ï¼Œä¸”ç­‰å€™å€æ»¿4äºº
            else if (currentCourtA.length > 0 && currentCourtB.length === 0 && !courtAFinished) {
                const onCourtA = currentCourtA.filter(p => p).length;
                const waiting = players.filter(p => !currentCourtA.includes(p));
                if (waiting.length >= 4 && waitingCount >= 4) {
                    startCourtB();
                }
            }
        }
        
        // é–‹å§‹Bå ´
        function startCourtB() {
            if (nextPlayerIndex < players.length) {
                const remaining = players.length - nextPlayerIndex;
                if (remaining >= 4) {
                    currentCourtB = players.slice(nextPlayerIndex, nextPlayerIndex + 4);
                    nextPlayerIndex += 4;
                    currentCourtB.forEach(p => playerMatchCount[p]++);
                    displayMatch();
                }
            }
        }

        // æ›´æ–°é¡¯ç¤º
        function updateDisplay() {
            document.getElementById('totalPlayers').textContent = players.length;
            
            const playersList = document.getElementById('playersList');
            if (players.length > 0) {
                playersList.innerHTML = `
                    <div style="margin-top: 20px;">
                        <strong style="color: #667eea;">å·²ç™»è¨˜çƒå“¡ (${players.length}/16)</strong>
                        <div class="players-list" style="margin-top: 10px;">
                            ${players.map((name, idx) => 
                                `<div class="player-badge">${idx + 1}. ${name}</div>`
                            ).join('')}
                        </div>
                    </div>
                `;
            } else {
                playersList.innerHTML = '<div class="empty-state">å°šç„¡çƒå“¡ç™»è¨˜</div>';
            }
        }

        // é–‹å§‹æ¯”è³½
        function startGame() {
            if (players.length < 4) {
                alert('è‡³å°‘éœ€è¦4ä½çƒå“¡æ‰èƒ½é–‹å§‹ï¼');
                return;
            }
            
            nextPlayerIndex = 0;
            finishedMatches = 0;
            players.forEach(p => playerMatchCount[p] = 0);
            
            nextMatch();
        }

        // é–‹å§‹ä¸‹ä¸€å ´æ¯”è³½
        function nextMatch() {
            courtAFinished = false;
            courtBFinished = false;
            currentCourtA = [];
            currentCourtB = [];
            
            // å¦‚æœé‚„æœ‰äººæŒ‰é †åºæ²’ä¸Šå ´éï¼Œå„ªå…ˆæŒ‰é †åºåˆ†é…
            if (nextPlayerIndex < players.length) {
                assignByOrder();
            } else {
                // æ‰€æœ‰äººéƒ½æŒ‰é †åºä¸Šéå ´äº†ï¼Œæ”¹ç”¨äº‚æ•¸é…å°
                assignByRandom();
            }
            
            displayMatch();
            saveToFirebase();
        }

        // æŒ‰é †åºåˆ†é…
        function assignByOrder() {
            const remaining = players.length - nextPlayerIndex;
            
            if (remaining >= 8) {
                // é‚„æœ‰8äººä»¥ä¸Šï¼Œé–‹å…©å ´
                currentCourtA = players.slice(nextPlayerIndex, nextPlayerIndex + 4);
                currentCourtB = players.slice(nextPlayerIndex + 4, nextPlayerIndex + 8);
                nextPlayerIndex += 8;
            } else if (remaining >= 4) {
                // é‚„æœ‰4-7äººï¼Œé–‹ä¸€å ´
                currentCourtA = players.slice(nextPlayerIndex, nextPlayerIndex + 4);
                nextPlayerIndex += 4;
            } else {
                // ä¸è¶³4äººï¼Œæ··åˆäº‚æ•¸é…å°
                assignByRandom();
                return;
            }
            
            // æ›´æ–°å‡ºè³½æ¬¡æ•¸
            currentCourtA.forEach(p => playerMatchCount[p]++);
            currentCourtB.forEach(p => playerMatchCount[p]++);
        }

        // äº‚æ•¸é…å°
        function assignByRandom() {
            // æŒ‰å‡ºè³½æ¬¡æ•¸æ’åºï¼Œå„ªå…ˆé¸æ“‡æ‰“è¼ƒå°‘å ´çš„çƒå“¡
            const sortedPlayers = [...players].sort((a, b) => 
                playerMatchCount[a] - playerMatchCount[b]
            );
            
            // éš¨æ©Ÿæ‰“äº‚å‰Nå
            const available = sortedPlayers.slice(0, Math.min(sortedPlayers.length, 8));
            const shuffled = available.sort(() => Math.random() - 0.5);
            
            if (shuffled.length >= 8) {
                currentCourtA = shuffled.slice(0, 4);
                currentCourtB = shuffled.slice(4, 8);
            } else if (shuffled.length >= 4) {
                currentCourtA = shuffled.slice(0, 4);
            } else {
                alert('çƒå“¡äººæ•¸ä¸è¶³4äººï¼Œç„¡æ³•é–‹å§‹æ¯”è³½ï¼');
                return;
            }
            
            // æ›´æ–°å‡ºè³½æ¬¡æ•¸
            currentCourtA.forEach(p => playerMatchCount[p]++);
            currentCourtB.forEach(p => playerMatchCount[p]++);
        }

        // é¡¯ç¤ºæ¯”è³½
        function displayMatch() {
            document.getElementById('currentMatch').style.display = 'block';
            
            const court1 = currentCourtA;
            const court2 = currentCourtB;
            
            // é¡¯ç¤ºçƒå ´
            let courtsHTML = '';
            
            if (currentCourtA.length > 0) {
                courtsHTML += `
                    <div class="court ${courtAFinished ? 'finished' : ''}">
                        <div class="court-title">ğŸ¸ çƒå ´ A</div>
                        <div class="court-players">
                            ${currentCourtA.map(p => 
                                `<div class="player-item">${p} (ç¬¬${playerMatchCount[p]}å ´)</div>`
                            ).join('')}
                        </div>
                        ${!courtAFinished ? 
                            '<button class="btn btn-success" onclick="finishCourt(\'A\')" style="width: 100%;">æ¯”è³½çµæŸï¼ˆè‡ªå‹•æ›¿è£œï¼‰</button>' : 
                            '<div style="text-align: center; color: #dc3545; font-weight: bold;">âœ… å·²çµæŸï¼ˆç­‰å¾…æ›´å¤šçƒå“¡ï¼‰</div>'
                        }
                    </div>
                `;
            }
            
            if (currentCourtB.length > 0) {
                courtsHTML += `
                    <div class="court ${courtBFinished ? 'finished' : ''}">
                        <div class="court-title">ğŸ¸ çƒå ´ B</div>
                        <div class="court-players">
                            ${currentCourtB.map(p => 
                                `<div class="player-item">${p} (ç¬¬${playerMatchCount[p]}å ´)</div>`
                            ).join('')}
                        </div>
                        ${!courtBFinished ? 
                            '<button class="btn btn-success" onclick="finishCourt(\'B\')" style="width: 100%;">æ¯”è³½çµæŸï¼ˆè‡ªå‹•æ›¿è£œï¼‰</button>' : 
                            '<div style="text-align: center; color: #dc3545; font-weight: bold;">âœ… å·²çµæŸï¼ˆç­‰å¾…æ›´å¤šçƒå“¡ï¼‰</div>'
                        }
                    </div>
                `;
            }
            
            document.getElementById('courtsContainer').innerHTML = courtsHTML;
            
            // æ›´æ–°å ´ä¸Šäººæ•¸å’Œç­‰å€™å€
            const onCourt = [...currentCourtA, ...currentCourtB];
            const waiting = players.filter(p => !onCourt.includes(p));
            
            document.getElementById('onCourtCount').textContent = onCourt.length;
            
            // æ›´æ–°ç­‰å€™å€
            const waitingBoxCard = document.getElementById('waitingBoxCard');
            if (waiting.length > 0) {
                waitingBoxCard.style.display = 'block';
                document.getElementById('waitingPlayers').innerHTML = waiting.map(p => 
                    `<div class="waiting-player">${p}<br><small>å·²æ‰“${playerMatchCount[p]}å ´</small></div>`
                ).join('');
            } else {
                waitingBoxCard.style.display = 'none';
            }
            
            // æª¢æŸ¥æ˜¯å¦é¡¯ç¤ºä¸‹ä¸€å ´æŒ‰éˆ•
            checkNextRound();
        }

        // æ¨™è¨˜çƒå ´çµæŸä¸¦è‡ªå‹•æ›¿è£œ
        function finishCourt(court) {
            if (court === 'A') {
                courtAFinished = true;
                finishedMatches++;
                // Aå ´çµæŸï¼Œè‡ªå‹•æ›¿è£œ
                autoReplaceCourtA();
            } else if (court === 'B') {
                courtBFinished = true;
                finishedMatches++;
                // Bå ´çµæŸï¼Œè‡ªå‹•æ›¿è£œ
                autoReplaceCourtB();
            }
            
            document.getElementById('finishedMatches').textContent = finishedMatches;
            saveToFirebase();
        }
        
        // è‡ªå‹•æ›¿è£œAå ´
        function autoReplaceCourtA() {
            // è¨ˆç®—å¯ç”¨çƒå“¡ï¼ˆæ‰€æœ‰çƒå“¡æ¸›å»Bå ´æ­£åœ¨æ‰“çš„ï¼‰
            const onCourtB = (courtBFinished || currentCourtB.length === 0) ? [] : currentCourtB;
            const availablePlayers = players.filter(p => !onCourtB.includes(p));
            
            if (availablePlayers.length < 4) {
                // å¯ç”¨äººæ•¸ä¸è¶³4äººï¼Œä¿æŒç­‰å€™ç‹€æ…‹
                displayMatch();
                return;
            }
            
            // å¦‚æœé‚„æœ‰äººæŒ‰é †åºæ²’ä¸Šå ´é
            if (nextPlayerIndex < players.length) {
                const notYetPlayed = players.slice(nextPlayerIndex).filter(p => !onCourtB.includes(p));
                
                if (notYetPlayed.length >= 4) {
                    // é‚„æœ‰4äººä»¥ä¸Šæ²’æ‰“éï¼ŒæŒ‰é †åºå–4äºº
                    currentCourtA = notYetPlayed.slice(0, 4);
                    // æ›´æ–°nextPlayerIndex
                    notYetPlayed.slice(0, 4).forEach(p => {
                        const idx = players.indexOf(p);
                        if (idx + 1 > nextPlayerIndex) nextPlayerIndex = idx + 1;
                    });
                } else if (notYetPlayed.length > 0) {
                    // é‚„æœ‰1-3äººæ²’æ‰“éï¼Œéœ€è¦è£œé½Š
                    const alreadyPlayed = availablePlayers.filter(p => 
                        !notYetPlayed.includes(p) && playerMatchCount[p] > 0
                    );
                    const shuffled = alreadyPlayed.sort(() => Math.random() - 0.5);
                    const needCount = 4 - notYetPlayed.length;
                    currentCourtA = [...notYetPlayed, ...shuffled.slice(0, needCount)];
                    nextPlayerIndex = players.length;
                } else {
                    // æ‰€æœ‰äººéƒ½æŒ‰é †åºæ‰“éäº†ï¼Œæ”¹ç”¨äº‚æ•¸
                    assignRandomForCourt('A');
                    return;
                }
            } else {
                // æ”¹ç”¨äº‚æ•¸é…å°
                assignRandomForCourt('A');
                return;
            }
            
            currentCourtA.forEach(p => playerMatchCount[p]++);
            courtAFinished = false;
            displayMatch();
        }
        
        // è‡ªå‹•æ›¿è£œBå ´
        function autoReplaceCourtB() {
            // è¨ˆç®—å¯ç”¨çƒå“¡ï¼ˆæ‰€æœ‰çƒå“¡æ¸›å»Aå ´æ­£åœ¨æ‰“çš„ï¼‰
            const onCourtA = (courtAFinished || currentCourtA.length === 0) ? [] : currentCourtA;
            const availablePlayers = players.filter(p => !onCourtA.includes(p));
            
            if (availablePlayers.length < 4) {
                // å¯ç”¨äººæ•¸ä¸è¶³4äººï¼Œä¿æŒç­‰å€™ç‹€æ…‹
                displayMatch();
                return;
            }
            
            // å¦‚æœé‚„æœ‰äººæŒ‰é †åºæ²’ä¸Šå ´é
            if (nextPlayerIndex < players.length) {
                const notYetPlayed = players.slice(nextPlayerIndex).filter(p => !onCourtA.includes(p));
                
                if (notYetPlayed.length >= 4) {
                    // é‚„æœ‰4äººä»¥ä¸Šæ²’æ‰“éï¼ŒæŒ‰é †åºå–4äºº
                    currentCourtB = notYetPlayed.slice(0, 4);
                    // æ›´æ–°nextPlayerIndex
                    notYetPlayed.slice(0, 4).forEach(p => {
                        const idx = players.indexOf(p);
                        if (idx + 1 > nextPlayerIndex) nextPlayerIndex = idx + 1;
                    });
                } else if (notYetPlayed.length > 0) {
                    // é‚„æœ‰1-3äººæ²’æ‰“éï¼Œéœ€è¦è£œé½Š
                    const alreadyPlayed = availablePlayers.filter(p => 
                        !notYetPlayed.includes(p) && playerMatchCount[p] > 0
                    );
                    const shuffled = alreadyPlayed.sort(() => Math.random() - 0.5);
                    const needCount = 4 - notYetPlayed.length;
                    currentCourtB = [...notYetPlayed, ...shuffled.slice(0, needCount)];
                    nextPlayerIndex = players.length;
                } else {
                    // æ‰€æœ‰äººéƒ½æŒ‰é †åºæ‰“éäº†ï¼Œæ”¹ç”¨äº‚æ•¸
                    assignRandomForCourt('B');
                    return;
                }
            } else {
                // æ”¹ç”¨äº‚æ•¸é…å°
                assignRandomForCourt('B');
                return;
            }
            
            currentCourtB.forEach(p => playerMatchCount[p]++);
            courtBFinished = false;
            displayMatch();
        }
        
        // ç‚ºæŒ‡å®šçƒå ´äº‚æ•¸é…å°
        function assignRandomForCourt(court) {
            // æ‰¾å‡ºä¸åœ¨å ´ä¸Šçš„çƒå“¡
            const onCourt = [...currentCourtA, ...currentCourtB];
            const available = players.filter(p => !onCourt.includes(p));
            
            if (available.length < 4) {
                // ä¸è¶³4äººï¼Œé¡¯ç¤ºæç¤º
                displayMatch();
                return;
            }
            
            // æŒ‰å‡ºè³½æ¬¡æ•¸æ’åº
            const sortedAvailable = available.sort((a, b) => 
                playerMatchCount[a] - playerMatchCount[b]
            );
            
            // éš¨æ©Ÿæ‰“äº‚å‡ºè³½æ¬¡æ•¸æœ€å°‘çš„çƒå“¡
            const minMatches = Math.min(...available.map(p => playerMatchCount[p]));
            const leastPlayed = sortedAvailable.filter(p => playerMatchCount[p] === minMatches);
            const others = sortedAvailable.filter(p => playerMatchCount[p] > minMatches);
            
            const shuffledLeast = leastPlayed.sort(() => Math.random() - 0.5);
            const shuffledOthers = others.sort(() => Math.random() - 0.5);
            const selected = [...shuffledLeast, ...shuffledOthers].slice(0, 4);
            
            if (court === 'A') {
                currentCourtA = selected;
                currentCourtA.forEach(p => playerMatchCount[p]++);
                courtAFinished = false;
            } else {
                currentCourtB = selected;
                currentCourtB.forEach(p => playerMatchCount[p]++);
                courtBFinished = false;
            }
            
            displayMatch();
        }



        // Firebase å³æ™‚åŒæ­¥
        function startRealtimeSync() {
            if (!isFirebaseEnabled) return;
            
            unsubscribe = db.collection('badminton').doc('gameState').onSnapshot((doc) => {
                if (doc.exists) {
                    const data = doc.data();
                    players = data.players || [];
                    playerMatchCount = data.playerMatchCount || {};
                    nextPlayerIndex = data.nextPlayerIndex || 0;
                    currentCourtA = data.currentCourtA || [];
                    currentCourtB = data.currentCourtB || [];
                    courtAFinished = data.courtAFinished || false;
                    courtBFinished = data.courtBFinished || false;
                    finishedMatches = data.finishedMatches || 0;
                    
                    updateDisplay();
                    if (currentCourtA.length > 0 || currentCourtB.length > 0) {
                        displayMatch();
                    }
                    console.log('ğŸ“¡ è³‡æ–™å·²åŒæ­¥');
                }
            }, (error) => {
                console.error('åŒæ­¥éŒ¯èª¤:', error);
            });
        }
        
        // å„²å­˜åˆ° Firebase
        function saveToFirebase() {
            if (!isFirebaseEnabled) {
                console.log('æœ¬åœ°æ¨¡å¼ï¼šè³‡æ–™å·²æ›´æ–°');
                return;
            }
            
            const gameState = {
                players,
                playerMatchCount,
                nextPlayerIndex,
                currentCourtA,
                currentCourtB,
                courtAFinished,
                courtBFinished,
                finishedMatches,
                lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            db.collection('badminton').doc('gameState').set(gameState)
                .then(() => console.log('ğŸ’¾ è³‡æ–™å·²å„²å­˜'))
                .catch(error => console.error('å„²å­˜å¤±æ•—:', error));
        }

        // é‡ç½®æ¯”è³½
        function resetGame() {
            if (!confirm('ç¢ºå®šè¦é‡ç½®æ¯”è³½å—ï¼Ÿæ‰€æœ‰è³‡æ–™å°‡æœƒæ¸…ç©ºã€‚')) {
                return;
            }
            
            players = [];
            playerMatchCount = {};
            nextPlayerIndex = 0;
            currentCourtA = [];
            currentCourtB = [];
            courtAFinished = false;
            courtBFinished = false;
            finishedMatches = 0;
            
            document.getElementById('currentMatch').style.display = 'none';
            document.getElementById('finishedMatches').textContent = '0';
            
            updateDisplay();
            
            if (isFirebaseEnabled) {
                saveToFirebase();
            }
        }

        // é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–
        window.onload = function() {
            updateDisplay();
        };
    </script>
</body>
</html>
